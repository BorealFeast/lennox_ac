#![feature(ptr_from_ref)]
pub mod logger;
mod midea_ac;

use anyhow::Result;
use core::str;
use embedded_svc::mqtt::client::{
    Event::{self, Received}, QoS,
};
use esp_idf_hal::{
    gpio::{ OutputPin},
    prelude::*,
    reset,
};
use esp_idf_svc::eventloop::EspSystemEventLoop;
use esp_idf_svc::mqtt::client::{EspMqttClient, EspMqttMessage, MqttClientConfiguration};
use log::{error, info};
use rgb_led::{RGB8, WS2812RMT};
use std::{
    rc::Rc,
    sync::{Arc, Mutex},
    thread::sleep,
    time::Duration,
};

use serde::{Serialize, Deserialize};
use wifi::wifi;
// If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
use esp_idf_sys::{self as _, EspError};

//use esp_backtrace as _;


use crate::{logger::Logger, midea_ac::{MideaAC, StateListener}};


#[toml_cfg::toml_config]
pub struct Config {
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> Result<()> {
    esp_idf_sys::link_patches();
    // esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;
    // EspLogger::initialize_default();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let _wifi = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    //     // Client configuration:
    let broker_url = if app_config.mqtt_user != "" {
        format!(
            "mqtt://{}:{}@{}",
            app_config.mqtt_user, app_config.mqtt_pass, app_config.mqtt_host
        )
    } else {
        format!("mqtt://{}", app_config.mqtt_host)
    };

    let mqtt_config = MqttClientConfiguration {
        ..Default::default()
    };

    let message_adapter = Arc::new(Mutex::new(MqttMessageAdapter { listeners: None }));

    let message_adapter_set = message_adapter.clone();

    let mut client = EspMqttClient::new(&broker_url, &mqtt_config, move |message_result| {
        println!("Reveived result message: {:?}", message_result);
        message_adapter.lock().unwrap().consume(message_result);
    })?;

    if let reset::ResetReason::Panic = reset::ResetReason::get() {}

    let payload = "hello esp".as_bytes();
    client.publish("esp/test", QoS::AtMostOnce, false, payload)?;

    let client = Arc::new(Mutex::new(client));

    let pins = peripherals.pins;
    let pin15 = pins.gpio15;
    let _scl = pins.gpio8;
    let _i2c = peripherals.i2c0;

    println!("LOOOOOPINGGG");

    let logger = MqttLogger { client: client.clone() };

    let b_logger = Rc::new(logger) as Rc<dyn Logger>;

    let stateListener = Box::new(StateListenerImpl{ client: client.clone() }) as Box<dyn StateListener>;

    let midea_ac = Arc::new(Mutex::new(MideaAC::new(
        peripherals.uart2,
        b_logger,
        pins.gpio17,
        pins.gpio16,
        pin15,
        stateListener
    )));

    let listener = MqttMessageListenerImpl {
        lennox_ac: midea_ac.clone(),
    };

    message_adapter_set.lock().unwrap().observe(listener);
    client.lock().unwrap().subscribe("esp/command", QoS::AtLeastOnce).unwrap();
    let mut panic = esp_idf_sys::panic_info_t::default();
    unsafe{
        esp_idf_sys::panic_print_dec(::core::ffi::c_int::MAX);
        esp_idf_sys::esp_core_dump_init();
        dump_to_uart(std::ptr::from_mut(&mut panic));
    }

    let mut led = WS2812RMT::new(pins.gpio2, peripherals.rmt.channel0)?;
    led.set_pixel(RGB8::new(1, 1, 0))?;
    loop {
        midea_ac.lock().unwrap().request_status();
        sleep(Duration::from_secs(5));
        println!("looping");
    }
}

pub unsafe extern "C" fn dump_to_uart(panic_info_t: *mut  esp_idf_sys::panic_info_t)  {
    extern "C" {
        // Declare it manually, because if certain ESP IDF components are not included (VFS?)
        // as is the case for CMake based builds, the signature of the `stat` fn is actually
        // not defined in the `esp-idf-sys` bindings
        #[link_name = "esp_core_dump_uart"]
        fn esp_core_dump_to_uart(panic_info_t: *mut  esp_idf_sys::panic_info_t);
    }

    esp_core_dump_to_uart(panic_info_t)
}

fn log_mttq(client: &mut EspMqttClient, text: &[u8]) {
    if let Err(e) = client.publish("esp/log", QoS::AtMostOnce, false, text) {
        println!(
            "Error sending esp/log message {} with error {:?}",
            String::from_utf8_lossy(text),
            e
        );
    }
}

trait MqttMessageListener {
    fn listen(&self, message: &Result<Event<EspMqttMessage>, EspError>);
}

struct MqttMessageListenerImpl<'a, C: OutputPin> {
    lennox_ac: Arc<Mutex<MideaAC<'a, C>>>,
}

impl<'a, C: OutputPin> MqttMessageListener for MqttMessageListenerImpl<'a, C> {
    fn listen(&self, event: &Result<Event<EspMqttMessage>, EspError>) {
        println!("Reveived result message: {:?}", event);
        if let Ok(Received(message)) = event {
            if let Some(_topic @ "esp/command") = message.topic() {
                let content = str::from_utf8(message.data());
                match content {
                    Ok("lock") => self.lennox_ac.lock().unwrap().lock_ac(),
                    Ok("unlock") => self.lennox_ac.lock().unwrap().unlock_ac(),
                    Ok(text) => {
                        if text.starts_with("temp: "){
                            let temp :u8 = text.split_once(' ').unwrap().1.parse().unwrap();
                            self.lennox_ac.lock().unwrap().send_state(temp);
                        }
                        self.lennox_ac.lock().unwrap().log_and_mttq(text.to_string())
                    },
                    Err(e) => println!("Unexpected message error: {}", e),
                }
            }
        }
    }
}

struct StateListenerImpl {
    client: Arc<Mutex<EspMqttClient>>,
}

impl crate::midea_ac::StateListener for StateListenerImpl {
    fn listen(&self, state: &midea_ac::State) {
        let stateJson = serde_json::to_string(&state).unwrap();
        if let Err(e) =
            self.client
                .lock()
                .unwrap()
                .publish("esp/floor1/state", QoS::AtMostOnce, false, stateJson.as_bytes())
        {
            println!("Error sending esp/log message {} with error {:?}", stateJson, e);
        }
    }
}



struct MqttMessageAdapter<'a> {
    listeners: Option<Box<dyn MqttMessageListener + 'a>>,
}

impl<'a> MqttMessageAdapter<'a> {
    fn observe<C: OutputPin>(&mut self, listener: MqttMessageListenerImpl<'a, C>) {
        self.listeners = Some(Box::new(listener));
    }

    fn consume(&self, message: &Result<Event<EspMqttMessage>, EspError>) {
        if let Some(listener) = &self.listeners {
            listener.listen(message);
        }
    }
}

unsafe impl<'a> Send for MqttMessageAdapter<'a> {}

struct MqttLogger {
    client: Arc<Mutex<EspMqttClient>>,
}

impl crate::logger::Logger for MqttLogger {
    fn log(&self, text: &str) {
        println!("MttqLogger: {:?}", text);
        if let Err(e) =
            self.client
                .lock()
                .unwrap()
                .publish("esp/log", QoS::AtMostOnce, false, text.as_bytes())
        {
            println!("Error sending esp/log message {} with error {:?}", text, e);
        }
    }
}
